<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Three.js · 3D 粒子圣诞树</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(1000px 600px at 10% 10%,#14213d 0%,transparent 60%),radial-gradient(800px 500px at 90% 20%,#0a9396 0%,transparent 60%),radial-gradient(900px 500px at 20% 90%,#ee9b00 0%,transparent 60%),linear-gradient(180deg,#070b14,#0b1020)}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:16px;top:16px;z-index:10;padding:12px;border-radius:14px;background:linear-gradient(180deg,#ffffff24,#ffffff12);backdrop-filter:blur(10px);border:1px solid #ffffff35;color:#fff;user-select:none}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .hud button,.hud input[type=range]{appearance:none;border:none;border-radius:10px}
    .btn{padding:8px 12px;font-size:14px;background:linear-gradient(45deg,#ffd56e,#ff5ea1);color:#1a1024;cursor:pointer}
    .btn.alt{background:linear-gradient(45deg,#6e9bff,#a66eff);color:#0b0f1a}
    .label{font-size:13px;opacity:.9;min-width:80px}
    .range{width:160px}
    .footer{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);color:#fff9;font-size:13px}
    .bless{position:fixed;left:50%;top:10%;transform:translateX(-50%);z-index:9;text-align:center}
    .bless .title{font-size:48px;letter-spacing:.06em;background:linear-gradient(90deg,#ffd56e,#ff7eb3,#6eb5ff);-webkit-background-clip:text;background-clip:text;color:transparent;filter:drop-shadow(0 0 18px #ffffff44);animation:shine 6s linear infinite}
    .bless .sub{margin-top:8px;font-size:18px;opacity:.9}
    .bless .tw{margin-top:6px;font-size:16px;letter-spacing:.02em;color:#ffe6f3;opacity:0;transition:opacity .6s ease}
    .bless .tw.show{opacity:1}
    .bless .title.flash{animation:shine 6s linear infinite,titleFlash .8s ease-out}
    @keyframes shine{0%{background-position:0% 50%}100%{background-position:100% 50%}}
    @keyframes titleFlash{0%{filter:drop-shadow(0 0 18px #ffffff44);transform:scale(1);opacity:1}35%{filter:drop-shadow(0 0 30px #ffe6ff);transform:scale(1.06);opacity:1}70%{filter:drop-shadow(0 0 22px #ffd6ff);transform:scale(1.03);opacity:.96}100%{filter:drop-shadow(0 0 18px #ffffff44);transform:scale(1);opacity:1}}
  </style>
</head>
<body>
  <div id="app"></div>
  <!-- hud removed -->
  <div class="footer">拖拽旋转 · 滚轮缩放 · 点击树冠彩灯闪烁</div>
  <div class="bless">
    <div class="title">黎紫威，圣诞快乐</div>
    <div class="sub">愿你被星光与温柔围绕，每一天都闪闪发亮</div>
    <div class="tw" id="bless-line"></div>
  </div>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.161.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.161.0/examples/jsm/"}}</script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

    const app = document.getElementById('app');
    const blessTitle = document.querySelector('.bless .title');
    const blessLine = document.getElementById('bless-line');
    const blessLines = [
      '愿所有悸动被温柔收藏',
      '今夜的心跳，刚好与你同频',
      '把星光和喜欢都给你',
      '雪落如诗，你如心愿成真',
      '见你的那刻，冬夜都变暖了'
    ];
    let blessIdx = 0, blessTimer;
    function typeBlessNext(){
      const text = blessLines[ blessIdx++ % blessLines.length ];
      clearInterval(blessTimer);
      blessLine.classList.remove('show');
      blessLine.textContent = '';
      let i = 0;
      blessTimer = setInterval(()=>{
        blessLine.textContent = text.slice(0, i++);
        if(i>text.length){
          clearInterval(blessTimer);
          requestAnimationFrame(()=> blessLine.classList.add('show'));
        }
      }, 60);
    }
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 4000);
    camera.position.set(0, 160, 900);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 260;
    controls.maxDistance = 1600;
    controls.target.set(0,160,0);

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.1, 0.4, 0.85);
    composer.addPass(bloomPass);
    const fxaa = new ShaderPass(FXAAShader);
    fxaa.material.uniforms[ 'resolution' ].value.set(1/innerWidth, 1/innerHeight);
    composer.addPass(fxaa);

    const tex = new THREE.CanvasTexture((()=>{const c=document.createElement('canvas');c.width=c.height=128;const g=c.getContext('2d');const grd=g.createRadialGradient(64,64,2,64,64,64);grd.addColorStop(0,'rgba(255,255,255,1)');grd.addColorStop(0.25,'rgba(255,210,160,0.95)');grd.addColorStop(0.5,'rgba(255,140,80,0.5)');grd.addColorStop(1,'rgba(0,0,0,0)');g.fillStyle=grd;g.fillRect(0,0,128,128);return c;})());
    tex.colorSpace = THREE.SRGBColorSpace;

    const TREE_H = 360;
    const BASE_R = 200;
    const COUNT = 5200;
    const positions = new Float32Array(COUNT*3);
    const colors = new Float32Array(COUNT*3);
    const sizes = new Float32Array(COUNT);
    const phases = new Float32Array(COUNT);
    for(let i=0;i<COUNT;i++){
      const u = Math.pow(Math.random(),0.8);
      const y = u*TREE_H;
      const r = (BASE_R*(1-u))*(0.75+0.25*Math.random());
      const tw = 10.5;
      const th = y*0.08 + i*0.005 + Math.random()*0.6;
      const x = Math.cos(th+tw*u)*r + (Math.random()-0.5)*6;
      const z = Math.sin(th+tw*u)*r + (Math.random()-0.5)*6;
      positions[i*3+0]=x;positions[i*3+1]=y;positions[i*3+2]=z;
      const h = 0.33 + (Math.random()*0.06-0.03);
      const s = 0.75;
      const l = 0.35 + 0.25*(1-u);
      const c = new THREE.Color().setHSL(h,s,l);
      colors[i*3+0]=c.r;colors[i*3+1]=c.g;colors[i*3+2]=c.b;
      sizes[i]=6+Math.random()*8;
      phases[i]=Math.random()*Math.PI*2;
    }
    const geoTree = new THREE.BufferGeometry();
    geoTree.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geoTree.setAttribute('color', new THREE.BufferAttribute(colors,3));
    geoTree.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    geoTree.setAttribute('phase', new THREE.BufferAttribute(phases,1));

    const matTree = new THREE.PointsMaterial({ size:8, map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
    const tree = new THREE.Points(geoTree, matTree);
    tree.position.y = 0;
    scene.add(tree);

    const LC = 320;
    const lpos = new Float32Array(LC*3);
    const lcol = new Float32Array(LC*3);
    const lpha = new Float32Array(LC);
    for(let i=0;i<LC;i++){
      const u = Math.random();
      const y = u*TREE_H;
      const r = BASE_R*(1-u)*0.9;
      const th = y*0.09 + i*0.21 + Math.random()*0.9;
      const x = Math.cos(th)*r + (Math.random()-0.5)*4;
      const z = Math.sin(th)*r + (Math.random()-0.5)*4;
      lpos[i*3]=x;lpos[i*3+1]=y;lpos[i*3+2]=z;
      const col = new THREE.Color().setHSL(Math.random(),0.9,0.6);
      lcol[i*3]=col.r;lcol[i*3+1]=col.g;lcol[i*3+2]=col.b;
      lpha[i]=Math.random()*Math.PI*2;
    }
    const geoLights = new THREE.BufferGeometry();
    geoLights.setAttribute('position', new THREE.BufferAttribute(lpos,3));
    geoLights.setAttribute('color', new THREE.BufferAttribute(lcol,3));
    geoLights.setAttribute('phase', new THREE.BufferAttribute(lpha,1));
    const matLights = new THREE.PointsMaterial({ size:16, map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
    const lightsPts = new THREE.Points(geoLights, matLights);
    scene.add(lightsPts);

    const star = new THREE.Mesh(new THREE.IcosahedronGeometry(22,1), new THREE.MeshBasicMaterial({ color:new THREE.Color(1,0.95,0.7) }));
    star.position.set(0, TREE_H+26, 0);
    scene.add(star);

    const SN = 900;
    const spos = new Float32Array(SN*3);
    const svel = new Float32Array(SN);
    for(let i=0;i<SN;i++){
      spos[i*3]=(Math.random()-0.5)*1800;
      spos[i*3+1]=Math.random()*1000;
      spos[i*3+2]=(Math.random()-0.5)*1200;
      svel[i]=0.4+Math.random()*0.8;
    }
    const geoSnow = new THREE.BufferGeometry();
    geoSnow.setAttribute('position', new THREE.BufferAttribute(spos,3));
    const matSnow = new THREE.PointsMaterial({ size:8, map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, color:new THREE.Color(1,1,1), sizeAttenuation:true, opacity:0.9 });
    const snowPts = new THREE.Points(geoSnow, matSnow);
    snowPts.position.y = 0;
    scene.add(snowPts);

    const heartTex = new THREE.CanvasTexture((()=>{const c=document.createElement('canvas');c.width=c.height=128;const g=c.getContext('2d');g.translate(64,64);g.beginPath();g.moveTo(0,34);g.bezierCurveTo(-52,-6,-44,-64,0,-40);g.bezierCurveTo(44,-64,52,-6,0,34);g.closePath();const grd=g.createLinearGradient(0,-44,0,44);grd.addColorStop(0,'rgba(255,245,252,1)');grd.addColorStop(0.35,'rgba(255,210,236,1)');grd.addColorStop(1,'rgba(255,165,214,1)');g.fillStyle=grd;g.shadowColor='rgba(255,195,238,0.98)';g.shadowBlur=26;g.fill();return c;})());
    heartTex.colorSpace = THREE.SRGBColorSpace;
    const HN = 220;
    const hpos = new Float32Array(HN*3);
    const hbaseX = new Float32Array(HN);
    const hbaseZ = new Float32Array(HN);
    const hsv = new Float32Array(HN);
    const hph = new Float32Array(HN);
    const hamp = new Float32Array(HN);
    for(let i=0;i<HN;i++){
      const u = Math.random();
      const r = BASE_R*0.8*(0.6+0.4*Math.random());
      const th = Math.random()*Math.PI*2;
      const bx = Math.cos(th)*r; const bz = Math.sin(th)*r;
      const y = -60 - Math.random()*220;
      hbaseX[i]=bx; hbaseZ[i]=bz; hsv[i]=0.6+Math.random()*0.9; hph[i]=Math.random()*Math.PI*2; hamp[i]=12+Math.random()*28;
      hpos[i*3]=bx; hpos[i*3+1]=y; hpos[i*3+2]=bz;
    }
    const geoHearts = new THREE.BufferGeometry();
    geoHearts.setAttribute('position', new THREE.BufferAttribute(hpos,3));
    const matHearts = new THREE.PointsMaterial({ size:46, map:heartTex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, color:new THREE.Color(1,0.82,0.92), sizeAttenuation:true, opacity:0.97 });
    const hearts = new THREE.Points(geoHearts, matHearts);
    scene.add(hearts);
    const heartBursts = [];
    let heartBurstCount = 0;

    let autoRotate = true;
    let lightsOn = true;
    let snowOn = true;
    let heartsOn = true;

    function resize(){
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      composer.setSize(innerWidth, innerHeight);
      bloomPass.setSize(innerWidth, innerHeight);
      fxaa.material.uniforms['resolution'].value.set(1/innerWidth, 1/innerHeight);
    }
    addEventListener('resize', resize);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('click', e=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
      mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse, camera);
      const pts = lightsPts;
      const pos = pts.geometry.attributes.position;
      let closest=-1; let min=1e9;
      const v = new THREE.Vector3();
      for(let i=0;i<pos.count;i++){
        v.set(pos.getX(i),pos.getY(i),pos.getZ(i));
        const p = v.clone().applyMatrix4(pts.matrixWorld);
        const sp = p.clone().project(camera);
        const dx = sp.x - mouse.x; const dy = sp.y - mouse.y; const d = dx*dx+dy*dy;
        if(d<min){min=d;closest=i}
      }
      if(closest>=0){
        const ph = pts.geometry.attributes.phase; ph.setX(closest, ph.getX(closest) + Math.PI*2); ph.needsUpdate=true;
      }
    });
    renderer.domElement.addEventListener('dblclick', e=>{
      const rect = renderer.domElement.getBoundingClientRect();
      heartBurstCount++;
      let center;
      let dir;
      if(heartBurstCount===3 && blessTitle){
        const b = blessTitle.getBoundingClientRect();
        const sx = ((b.left + b.width/2 - rect.left)/rect.width)*2-1;
        const sy = -(((b.top + b.height*0.6) - rect.top)/rect.height)*2+1;
        const ndc = new THREE.Vector3(sx,sy,0.5);
        ndc.unproject(camera);
        dir = ndc.sub(camera.position).normalize();
        center = camera.position.clone().add(dir.clone().multiplyScalar(420));
      }else{
        mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
        mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const origin = raycaster.ray.origin.clone();
        dir = raycaster.ray.direction.clone().normalize();
        center = origin.clone().add(dir.clone().multiplyScalar(420));
      }
      let up = new THREE.Vector3(0,1,0);
      if(Math.abs(dir.dot(up))>0.9) up = new THREE.Vector3(1,0,0);
      const u = new THREE.Vector3().crossVectors(dir, up).normalize();
      const v = new THREE.Vector3().crossVectors(u, dir).normalize();
      const N = 90;
      const arr = new Float32Array(N*3);
      const velocities = [];
      const scale = 10;
      function heart2D(t){const x=16*Math.sin(t)**3;const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);return {x,y};}
      for(let i=0;i<N;i++){
        const tt = (i/N)*Math.PI*2;
        const h = heart2D(tt);
        const jitter = 1 + (Math.random()-0.5)*0.14;
        const hx = h.x*scale*jitter;
        const hy = h.y*scale*jitter;
        const wp = center.clone().add(u.clone().multiplyScalar(hx)).add(v.clone().multiplyScalar(hy));
        arr[i*3]=wp.x; arr[i*3+1]=wp.y; arr[i*3+2]=wp.z;
        const vel = wp.clone().sub(center).normalize().multiplyScalar(140+Math.random()*90);
        velocities.push(vel);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
      const mat = new THREE.PointsMaterial({ size:58, map:heartTex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, color:new THREE.Color(1,0.8,0.94), sizeAttenuation:true, opacity:0.96 });
      const pts = new THREE.Points(geo, mat);
      scene.add(pts);
      heartBursts.push({ pts, velocities, life:1.6, maxLife:1.6 });
      if(blessTitle){
        blessTitle.classList.remove('flash');
        void blessTitle.offsetWidth;
        blessTitle.classList.add('flash');
        setTimeout(()=>{blessTitle.classList.remove('flash');},800);
      }
    });

    const BASE_SIZE = 8;
    const BLOOM_STRENGTH = 1.1;

    let audioCtx, analyser, gainNode, oscs=[], audioOn=false, energy=0;
    function initAudio(){ if(audioCtx) return; audioCtx = new (window.AudioContext||window.webkitAudioContext)(); gainNode = audioCtx.createGain(); gainNode.gain.value = 0; analyser = audioCtx.createAnalyser(); analyser.fftSize = 256; const lfo = audioCtx.createOscillator(); const lfoGain = audioCtx.createGain(); lfo.frequency.value = 0.18; lfoGain.gain.value = 18; const notes=[220,277,330,392]; for(let i=0;i<3;i++){ const o=audioCtx.createOscillator(); o.type = i===0?'triangle':i===1?'sine':'square'; o.frequency.value = notes[i]; const g=audioCtx.createGain(); g.gain.value=0.18; o.connect(g); g.connect(gainNode); oscs.push(o); } const bass = audioCtx.createOscillator(); bass.type='sine'; bass.frequency.value=110; const gb=audioCtx.createGain(); gb.gain.value=0.16; bass.connect(gb); gb.connect(gainNode); lfo.connect(lfoGain); lfoGain.connect(oscs[1].frequency); oscs.forEach(o=>o.start()); bass.start(); lfo.start(); gainNode.connect(analyser); analyser.connect(audioCtx.destination); }
    function toggleMusic(){ initAudio(); audioOn = !audioOn; if(audioOn){ const t=audioCtx.currentTime; gainNode.gain.cancelScheduledValues(t); gainNode.gain.linearRampToValueAtTime(0.32, t+0.5); }else{ const t=audioCtx.currentTime; gainNode.gain.cancelScheduledValues(t); gainNode.gain.linearRampToValueAtTime(0.0, t+0.4); } }
    // buttons removed; keep defaults

    let t = 0;
    let pendingBless = false;
    function animate(now){
      const dt = Math.min(0.05, (now - t)*0.001 || 0.016);
      t = now;
      controls.update();
      if(analyser){ const buf = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(buf); let sum=0, low=0, mid=0, high=0; for(let i=0;i<buf.length;i++){ const v=buf[i]/255; sum+=v; if(i<buf.length*0.2) low+=v; else if(i<buf.length*0.7) mid+=v; else high+=v; } const avg=sum/buf.length; const l=low/(buf.length*0.2); const m=mid/(buf.length*0.5); const h=high/(buf.length*0.3); energy += (avg - energy)*0.15; const baseSize = BASE_SIZE; matTree.size = baseSize * (1 + energy*0.4); matLights.size = baseSize*2 * (1 + m*0.6); bloomPass.strength = BLOOM_STRENGTH * (1 + h*0.5); star.scale.set(1+avg*0.6,1+avg*0.6,1+avg*0.6); }
      if(autoRotate){ scene.rotation.y += dt*(0.3 + energy*0.6); star.rotation.y += dt*(0.6 + energy*0.8); }
      const lt = now*0.004;
      const lphase = lightsPts.geometry.attributes.phase;
      const lposAttr = lightsPts.geometry.attributes.position;
      for(let i=0;i<lposAttr.count;i++){
        const s = 0.8 + 0.6*Math.sin(lt*2 + lphase.getX(i));
        matLights.size = BASE_SIZE*2;
      }
      if(heartsOn){
        const hp = geoHearts.attributes.position;
        for(let i=0;i<HN;i++){
          let y = hp.getY(i); y += (0.6+hsv[i])*(1+energy*0.7); if(y>TREE_H+140){ y = -80 - Math.random()*180; hph[i]=Math.random()*Math.PI*2; hamp[i]=12+Math.random()*28; }
          const x = hbaseX[i] + Math.sin(lt*0.8 + hph[i])*hamp[i];
          const z = hbaseZ[i] + Math.cos(lt*0.6 + hph[i])*hamp[i]*0.4;
          hp.setXYZ(i, x, y, z);
        }
        hp.needsUpdate = true;
        const baseHSize = 46; matHearts.size = baseHSize * (1 + energy*0.6);
        matHearts.opacity = 0.86 + Math.min(0.12, energy*0.3);
      }
      for(let i=heartBursts.length-1;i>=0;i--){
        const b = heartBursts[i];
        const posAttr = b.pts.geometry.attributes.position;
        const lifeRatio = Math.max(b.life/b.maxLife,0);
        const fade = lifeRatio*lifeRatio;
        for(let j=0;j<b.velocities.length;j++){
          const v = b.velocities[j];
          v.y -= 40*dt;
          const x = posAttr.getX(j) + v.x*dt;
          const y = posAttr.getY(j) + v.y*dt;
          const z = posAttr.getZ(j) + v.z*dt;
          posAttr.setXYZ(j,x,y,z);
        }
        posAttr.needsUpdate = true;
        b.pts.material.opacity = 0.95 * fade;
        b.pts.material.size = 58 * (1 + energy*0.7) * (0.6 + 0.4*fade);
        b.life -= dt;
        if(b.life<=0){ pendingBless = true; scene.remove(b.pts); b.pts.geometry.dispose(); b.pts.material.dispose(); heartBursts.splice(i,1); }
      }
      if(pendingBless){ pendingBless = false; typeBlessNext(); }
      const snowAttr = snowPts.geometry.attributes.position;
      for(let i=0;i<snowAttr.count;i++){
        let y = snowAttr.getY(i); y -= (0.6 + svel[i])*2; if(y<-50){ y = 900; snowAttr.setX(i,(Math.random()-0.5)*1800); } snowAttr.setY(i,y);
      }
      snowAttr.needsUpdate = true;
      composer.render();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
